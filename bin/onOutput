#!/bin/bash
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-i|--interval INTERVAL[SUFFIX]|-I|--immediate] [-l|--line-interval LINE-NUM] [-w|--non-whitespace] [-b|--before|-a|--append|-p|--piped] [-s|--skip PATTERN [...]] [-m|--match PATTERN [...]] -c|--command "COMMANDLINE" [-c ...] | [--] SIMPLECOMMAND [...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Whenever there is output (but at least INTERVAL (default: 1 second) or LINE-NUM
apart), execute the shell COMMANDS. If these fail, further processing is
aborted.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --interval|-i INTERVAL[SUFFIX]
			    Wait for INTERVAL seconds between executions of
			    COMMANDS, even if there's continuous output. SUFFIX
			    may be 's' for seconds (the default), 'm' for
			    minutes, 'h' for hours or 'd' for days.
    --immediate|-I	    Directly execute COMMANDS for every (matching / not
			    skipped) line; don't wait INTERVAL seconds.
    --line-interval|-l LINE-NUM
			    Wait until LINE-NUM lines have been output before
			    doing another execution of COMMANDS. If INTERVAL is
			    also given, one or the other has to be met.
    --non-whitespace|-w	    Only output that does contains at least one
			    non-whitespace character triggers COMMANDS
			    execution.
    --before|-b		    Execute COMMANDS before the output is printed
			    (instead of after it).
    --append|-a		    Execute COMMANDS after the output, but instead of a
			    concluding newline (so any line break has to come
			    from COMMANDS itself).
    --piped|-p		    Feed the output since the last invocation of
			    COMMANDS or the last encountered skipped line to
			    COMMANDS (which have to do any output themselves).
    --skip|-s PATTERN	    Ignore (but still print) lines that match PATTERN,
			    so that these don't trigger COMMANDS execution.
    --match|-m PATTERN	    Only consider lines that match PATTERN for
			    triggering COMMANDS execution; other lines (and
			    those that also match --skip PATTERN) are ignored.
HELPTEXT
}

interval=1
lineInterval=
isNeedEval=
typeset -a commands=()
isNonWhitespace=
mode=
skipPattern=
matchPattern=
process=print
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--interval|-i)	shift
			case "$1" in
			    +([0-9])?(s))   interval="${1%s}";;
			    +([0-9])m)	    interval=$((${1%m} * 60));;
			    +([0-9])h)	    interval=$((${1%h} * 3600));;
			    +([0-9])d)	    interval=$((${1%d} * 86400));;
			    *)		    printf >&2 'ERROR: Illegal interval: %s\n' "$1"; exit 2;;
			esac
			shift
			;;
	--immediate|-I)		shift; interval=0;;
	--line-interval|-l)	shift; lineInterval="${1:?}"; shift;;
	--non-whitespace|-w)	shift; isNonWhitespace=t;;
	--before|-b)	shift
			if [ "$mode" ]; then
			    echo >&2 "ERROR: Cannot combine --before with --${mode}."
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			fi
			mode=before
			;;
	--append|-a)	shift
			if [ "$mode" ]; then
			    echo >&2 "ERROR: Cannot combine --append with --${mode}."
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			fi
			mode=append
			;;
	--piped|-p)	shift
			if [ "$mode" ]; then
			    echo >&2 "ERROR: Cannot combine --piped with --${mode}."
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			fi
			mode=piped
			process=gather
			;;
	--command|-c)	shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--skip|-s)	shift; skipPattern="${skipPattern}${skipPattern:+|}${1:?}"; shift;;
	--match|-m)	shift; matchPattern="${matchPattern}${matchPattern:+|}${1:?}"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
: ${mode:=after}
if [ $# -ne 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	commands+=(${commands:+;} $(printf '%q ' "$@"))
    else
	commands=("$@")
    fi
fi
if [ ${#commands[@]} -eq 0 ]; then
    echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
    exit 2
fi

print()
{
    printf %s "$@"
}
gather()
{
    collectedLines="${collectedLines}$*"
}
runCommands()
(
    if [ "$isNeedEval" ]; then
	eval "${commands[@]}"
    else
	"${commands[@]}"
    fi
)

collectedLines=
EOL=$'\n'
SECONDS=0
lineCnt=0
while IFS=$'\n' read -r line || { EOL=; [ -n "$line" ]; }
do
    isSkipThisLine=
    [ "$matchPattern" ] && [[ ! "$line" =~ $matchPattern ]] && isSkipThisLine=t
    [ "$skipPattern" ] && [[ "$line" =~ $skipPattern ]] && isSkipThisLine=t
    if [ "$isSkipThisLine" ]; then
	if [ "$collectedLines" ]; then
	    printf %s "$collectedLines" | runCommands || exit $?
	    collectedLines=''
	    SECONDS=0
	    lineCnt=0
	fi

	printf %s "${line}$EOL"
	continue
    fi

    let lineCnt+=1
    if [ $SECONDS -lt $interval ] && { [ ! "$lineInterval" ] || [ $lineCnt -lt $lineInterval ]; }; then
	$process "${line}$EOL"
	continue
    fi

    if [ ! "$isNonWhitespace" ] || [[ "$line" =~ [^[:space:]] ]]; then
	case "$mode" in
	    after)  $process "${line}$EOL";;
	    append) $process "$line";;
	esac

	case "$mode" in
	    piped)  printf %s "$collectedLines" "${line}$EOL" | runCommands || exit $?
		    collectedLines=''
		    ;;
	    *)	    runCommands || exit $?;;
	esac

	case "$mode" in
	    before) $process "${line}$EOL";;
	esac

	SECONDS=0
	lineCnt=0
    fi
done
if [ "$collectedLines" ]; then
    printf %s "$collectedLines" | runCommands || exit $?
fi
